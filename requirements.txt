asgiref==3.7.2
Django==4.2.6
djangorestframework==3.14.0
modeltranslation==0.25
pytz==2023.3.post1
sqlparse==0.4.4
typing_extensions==4.8.0
tzdata==2023.3











class Client(models.Model):
    name = models.CharField(max_length=200)
    passport = models.CharField(max_length=9, null=True, blank=True)
    phone = models.CharField(max_length=9)
    desc = models.TextField(null=True, blank=True)
    @property
    def get_all_transactions(self):
        income_records = Income.objects.filter(client=self)
        outcome_records = Outcome.objects.filter(client=self)
        transactions = {
            'outcome': {},
            'income': {},
            'debt_counts': {},
        }

        # Calculate total income counts for each product
        total_income_counts = {}
        for income in income_records:
            product_name = income.product.name
            count = income.count
            total_income_counts[product_name] = total_income_counts.get(product_name, 0) + count

        # Calculate total outcome counts for each product
        total_outcome_counts = {}
        for outcome in outcome_records:
            product_name = outcome.product.name
            count = outcome.count
            total_outcome_counts[product_name] = total_outcome_counts.get(product_name, 0) + count

        for outcome in outcome_records:
            product_name = outcome.product.name
            count = outcome.count
            date = outcome.date
            total = outcome.total
            transactions['outcome'][product_name] = {
                'count': count,
                'date': date,
                'total': total,
            }

        for income in income_records:
            product_name = income.product.name
            count = income.count
            date = income.date
            total = income.total
            transactions['income'][product_name] = {
                'count': count,
                'date': date,
                'total': total,
            }

            # Update total_income directly in debt_counts
            transactions['debt_counts'][product_name] = {
                'count': 0,  # Placeholder for count, update this based on your requirements
                'total': total_outcome_counts.get(product_name, 0) - total_income_counts.get(product_name, 0),
                'status': "",  # Update this based on your requirements
            }

        for product_name in set(transactions['outcome'].keys()) | set(transactions['income'].keys()):
            outcome_info = transactions['outcome'].get(product_name, {'count': 0, 'date': None, 'total': 0})
            income_info = transactions['income'].get(product_name, {'count': 0, 'date': None, 'total': 0})

            outcome_count = outcome_info['count']
            income_count = total_income_counts.get(product_name, 0)
            product_debt_count = outcome_count - income_count
            transactions['debt_counts'][product_name]['count'] = product_debt_count

            # Check if both count and total are 0
            if product_debt_count == 0 and transactions['debt_counts'][product_name]['total'] == 0:
                transactions['debt_counts'][product_name]['status'] = "Shartnoma yakunlangan"
            else:
                transactions['debt_counts'][product_name]['status'] = "Qarzdorlik"

        return transactions

        
    def delete_completed(self):
        if self.status == "Shartnoma yakunlangan" and self.debt_product == 0:
            three_days_ago = timezone.now() - timezone.timedelta(minutes=3)
            if self.income.filter(date__lte=three_days_ago).exists():
                return
            self.delete()
    
    
    def __str__(self):
        return f"{self.name}"
    

    
# Outcome class

class Outcome(models.Model):
    client = models.ForeignKey(Client, on_delete=models.CASCADE)
    rent = models.ForeignKey(Rent, on_delete=models.CASCADE)
    product = models.ForeignKey(ProductType, on_delete=models.CASCADE)
    count = models.FloatField()
    price = models.PositiveBigIntegerField(null=True, blank=True)
    date = models.DateTimeField()
     
    @property
    def total(self):
        if self.price is not None and self.price > 0:
            return self.price * self.count
        elif self.product.price is not None:
            return self.product.price * self.count
        else:
            return 0


    
    def __str__(self):
        return f"{self.client_name} , {self.product.name}"

    
class Income(models.Model):
    class PayType(models.TextChoices):
        MAXSUS = "Maxsus to'lov", "Maxsus to'lov"
        TOLIQ = "To'liq yopish", "To'liq yopish"
    pay_type = models.CharField(max_length=30, choices=PayType.choices, null=True, blank=True)
    rent = models.ForeignKey(Rent, on_delete=models.CASCADE)
    client = models.ForeignKey(Client, on_delete=models.CASCADE)
    product = models.ForeignKey(ProductType, on_delete=models.CASCADE)
    count = models.PositiveBigIntegerField()
    pay = models.PositiveBigIntegerField(null=True, blank=True)
    day = models.IntegerField()
    date = models.DateTimeField()


    
    @property
    def total(self):
        if self.pay is not None and self.pay > 0:
            return self.pay * self.count
        elif self.product.price is not None:
            return self.product.price * self.count
        else:
            return 0

    def __str__(self):
        return f"{self.client.name} , {self.product.name}"




get_all_transactions dagi outcome va income dagi count va total ni Income va Outcome klassidagi count va total larni yig'indisini chiqarib beradigan kod yozib ber. Ya'ni Income va Outcome dagi count va total necha marta qo'shilsa, ularning mos yig'indilarini get_all_transactions dagigi income va outcome count va total ga natijasini qo'shib chiqarib beradigan kod yozib ber